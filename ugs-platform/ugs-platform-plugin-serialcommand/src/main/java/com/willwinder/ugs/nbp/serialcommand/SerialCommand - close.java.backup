package com.willwinder.ugs.nbp.serialcommand;

import com.fazecast.jSerialComm.SerialPort;
import com.willwinder.universalgcodesender.model.Axis;
import com.willwinder.universalgcodesender.model.BackendAPI;
import com.willwinder.universalgcodesender.model.BackendAPIReadOnly;
import com.willwinder.universalgcodesender.model.Position;
import com.willwinder.universalgcodesender.model.UnitUtils.Units;
import com.willwinder.universalgcodesender.services.JogService;
import com.willwinder.ugs.nbp.lib.lookup.CentralLookup;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Scanner;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.openide.modules.OnStart;
import org.openide.util.lookup.ServiceProvider;
import org.openide.windows.IOProvider;
import org.openide.windows.InputOutput;

@OnStart
@ServiceProvider(service = Runnable.class)
public class SerialCommand implements Runnable {

    private static final int BAUD_RATE = 9600;

    private SerialPort activePort;
    private OutputStream serialOut;
    private boolean connected = false;
    private volatile boolean dirty = false;
    private long lastUpdateTime = 0;
    private final ExecutorService updateExecutor = Executors.newSingleThreadExecutor();
    private JogService jogService;
    private BackendAPIReadOnly apiReadOnly;
    private Timer heartbeatTimer;
    private volatile boolean ackReceived = false;
    private volatile long lastAckSent = 0;

    static class MachineStatus {
        float x, y, z, a;
        byte status;
        float feedRate, line, total;
    }

    public SerialCommand() {
        this.jogService = null;
    }

    @Override
    public void run() {
        jogService = CentralLookup.getDefault().lookup(JogService.class);
        new Thread(this::startSerialConnection).start();
    }

    private void startSerialConnection() {
        InputOutput io = IOProvider.getDefault().getIO("SerialCommand", true);
        io.select();

        try {
            SerialPort selected = null;
            for (SerialPort port : SerialPort.getCommPorts()) {
                io.getOut().println("[SerialCommand] Trying port: " + port.getSystemPortName());
                port.setBaudRate(BAUD_RATE);
                port.setComPortTimeouts(SerialPort.TIMEOUT_NONBLOCKING, 0, 0);
                if (!port.openPort()) {
                    io.getOut().println("[SerialCommand] Failed to open port: " + port.getSystemPortName());
                    continue;
                }

                InputStream testInput = port.getInputStream();
                Scanner scanner = new Scanner(testInput);
                boolean found = false;

                while (scanner.hasNextLine()) {
                    String line = scanner.nextLine().trim();
                    io.getOut().println("[SerialCommand] Line: " + line);
                    if ("REQ".equals(line)) {
                        serialOut = port.getOutputStream();
                        serialOut.write("ACK\n".getBytes());
                        serialOut.flush();
                        lastAckSent = System.currentTimeMillis();
                        selected = port;
                        io.getOut().println("[SerialCommand] Pendant on " + port.getSystemPortName());
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    port.closePort();
                } else {
                    break;
                }
            }

            if (selected == null) {
                io.getErr().println("[SerialCommand] Pendant not found.");
                return;
            }

            InputStream in = selected.getInputStream();
            activePort = selected;

            apiReadOnly = CentralLookup.getDefault().lookup(BackendAPIReadOnly.class);
            if (apiReadOnly != null) {
                apiReadOnly.addUGSEventListener(e -> {
    io.getOut().println("[SerialCommand] UGS event received: " + e.getEventType());
    scheduleUpdate();
});
                scheduleUpdate();
            } else {
                io.getErr().println("[SerialCommand] BackendAPIReadOnly unavailable.");
            }

            Scanner scanner = new Scanner(in);

            while (scanner.hasNextLine()) {
                String line = scanner.nextLine().trim();
                io.getOut().println("[Pendant] " + line);

                if ("ACK".equals(line)) {
                    ackReceived = true;
                    continue;
                }

                if ("REQ".equals(line)) {
                    io.getOut().println("[Pendant] REQ received");
                    scheduleUpdate();

                    if (!connected) {
                        connected = true;
                        startHeartbeat(io);
                    }
                    continue;
                }

                if (line.startsWith("KEY:")) {
                    if (!connected) {
                        connected = true;
                        startHeartbeat(io);
                    }
                    try {
                        int code = Integer.parseInt(line.substring(4));
                        handleCode(code, io);
                    } catch (NumberFormatException ex) {
                        io.getErr().println("[SerialCommand] Bad key: " + line);
                    }
                }
            }
        } catch (Exception ex) {
            io.getErr().println("[SerialCommand] Serial error: " + ex.getMessage());
        }
    }

    private void startHeartbeat(InputOutput io) {
        heartbeatTimer = new Timer();
        heartbeatTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                if (!connected) return;
                try {
                    long now = System.currentTimeMillis();
                    if (serialOut != null) {
                        serialOut.write("ACK\n".getBytes());
                        serialOut.flush();
                        lastAckSent = now;
                    }

                    if (!ackReceived && now - lastAckSent > 30000) {
                        io.getOut().println("[SerialCommand] No ACK from pendant in last 30s â€” assuming disconnected.");
                        connected = false;
                        heartbeatTimer.cancel();
                        if (activePort != null) activePort.closePort();
                    }

                    ackReceived = false;
                } catch (Exception e) {
                    io.getErr().println("[SerialCommand] Heartbeat error: " + e.getMessage());
                }
            }
        }, 1000, 1000);
    }

    private void scheduleUpdate() {
        long now = System.currentTimeMillis();
        if (!dirty && (now - lastUpdateTime >= 200)) {
            dirty = true;
            lastUpdateTime = now;
            updateExecutor.submit(this::pushUpdate);
        }
    }

    private void pushUpdate() {

        if (!connected || apiReadOnly == null) return;
        if (!dirty) return;

        try {
            if (activePort != null && activePort.bytesAwaitingWrite() > 0) return;

            Position p = apiReadOnly.getWorkPosition();
            boolean metric = (jogService.getUnits() == Units.MM);

            double x = p.getX(), y = p.getY(), z = p.getZ(), a = Double.isNaN(p.getA()) ? 0 : p.getA();
            if (!metric) {
                x /= 25.4; y /= 25.4; z /= 25.4; a /= 25.4;
            }

            long total = apiReadOnly.getNumRows();
            long sent = apiReadOnly.getNumSentRows();
            int feedRate = CentralLookup.getDefault().lookup(JogService.class).getFeedRate();

            byte status = (byte) (apiReadOnly.isPaused() ? 1 : apiReadOnly.isSendingFile() ? 2 : apiReadOnly.isIdle() ? 0 : 3);

            MachineStatus m = new MachineStatus();
            m.x = (float)x; m.y = (float)y; m.z = (float)z; m.a = (float)a;
            m.status = status;
            m.feedRate = (float)feedRate;
            m.line = (float)sent;
            m.total = (float)total;

            ByteBuffer buffer = ByteBuffer.allocate(34);
            buffer.order(ByteOrder.LITTLE_ENDIAN);
            buffer.put("SYNC\n".getBytes());
            buffer.putFloat(Float.intBitsToFloat(Integer.reverseBytes(Float.floatToIntBits(m.x))));
            buffer.putFloat(Float.intBitsToFloat(Integer.reverseBytes(Float.floatToIntBits(m.y))));
            buffer.putFloat(Float.intBitsToFloat(Integer.reverseBytes(Float.floatToIntBits(m.z))));
            buffer.putFloat(Float.intBitsToFloat(Integer.reverseBytes(Float.floatToIntBits(m.a))));
            buffer.put(m.status);
            buffer.putFloat(Float.intBitsToFloat(Integer.reverseBytes(Float.floatToIntBits(m.feedRate))));
            buffer.putFloat(Float.intBitsToFloat(Integer.reverseBytes(Float.floatToIntBits(m.line))));
            buffer.putFloat(Float.intBitsToFloat(Integer.reverseBytes(Float.floatToIntBits(m.total))));

            serialOut.write(buffer.array());
            serialOut.flush();
            dirty = false;

        } catch (Exception e) {
            System.err.println("[SerialCommand] Failed to send MachineStatus: " + e.getMessage());
        }
    }

    private void handleCode(int code, InputOutput io) {
        BackendAPI backend = CentralLookup.getDefault().lookup(BackendAPI.class);
        JogService jog = CentralLookup.getDefault().lookup(JogService.class);
        if (backend == null || jog == null) {
            io.getErr().println("[SerialCommand] UGS services unavailable.");
            return;
        }
        try {
            switch (code) {
                case 0: jog.adjustManualLocationZ(-1); break;
                case 1: jog.adjustManualLocationABC(-1, 0, 0); break;
                case 2: jog.adjustManualLocationABC(1, 0, 0); break;
                case 3: jog.adjustManualLocationZ(1); break;
                case 4: jog.adjustManualLocationXY(0, -1); break;
                case 5: jog.adjustManualLocationXY(1, 0); break;
                case 6: jog.adjustManualLocationXY(0, 1); break;
                case 7: jog.adjustManualLocationXY(-1, 0); break;
                case 8: setStep(jog, 0.001); break;
                case 9: setStep(jog, 0.010); break;
                case 10: setStep(jog, 0.100); break;
                case 11: setStep(jog, 1.000); break;
                case 12: backend.resetCoordinateToZero(Axis.A); break;
                case 13: backend.resetCoordinateToZero(Axis.Z); break;
                case 14: backend.resetCoordinateToZero(Axis.Y); break;
                case 15: backend.resetCoordinateToZero(Axis.X); break;
                case 16: backend.sendGcodeCommand("G53 G0 A0"); break;
                case 17: backend.sendGcodeCommand("G53 G0 Z0"); break;
                case 18: backend.sendGcodeCommand("G53 G0 Y0"); break;
                case 19: backend.sendGcodeCommand("G53 G0 X0"); break;
                case 22: backend.returnToZero(); break;
                case 23: backend.performHomingCycle(); break;
                case 25: backend.send(); break;
                case 26: backend.pauseResume(); break;
                case 27: backend.cancel(); break;
                default: break;
            }
        } catch (Exception ex) {
            io.getErr().println("[SerialCommand] Error handling code " + code + ": " + ex.getMessage());
        }
    }

    private static void setStep(JogService j, double v) {
        j.setStepSizeZ(v);
        j.setStepSizeXY(v);
        j.setStepSizeABC(v);
    }
}
